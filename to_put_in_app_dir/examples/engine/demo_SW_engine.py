#-------------------------------------------------------------------------------
#
# This file shows how to simulate a four cylinder engine
#
# This is developed by modifying  the "run_test.py" as an example on
# how to load SolidWorks exported systems and then add some custom PyChrono
# customization.
#
# Author: Alessandro Tasora
#
# REMARK: this is part of Chrono::Solidworks add-in
#     - it assumes that you exported the .asm in this directory using the add-in
#     - PyChrono must be installed in your Python environment
#-------------------------------------------------------------------------------

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr


print("Demo program that shows how to use the SolidWorks add-in.")
print(" 1) use the SolidWorks Add-in, load the .SLDASM,")
print(" 2) from the Add-in, 'save as Python..' in a directory X")
print(" 3) modify m_datapath in this file")
print(" 3) modify ImportSolidWorksSystem(..) to match what you exported")
print(" 4) move this .py file in directory X and execute it.")


# ---------------------------------------------------------------------

m_timestep = 0.01
m_length = 1.0
m_visualization = "irrlicht"
m_datapath = "C:/Program Files/chrono_solidworks/data/" 

# For irrlicht fonts & background. Adjust to your path
chrono.SetChronoDataPath(m_datapath)


# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#

print ("Loading C::E scene...");

exported_items = chrono.ImportSolidWorksSystem('./Engine4c.py')

print ("...loading done!");



# Print exported items
for my_item in exported_items:
    print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
for my_item in exported_items:
    my_system.Add(my_item)


# Optionally set some solver parameters.

#my_system.SetMaxPenetrationRecoverySpeed(1.00)
my_solver = chrono.ChSolverBB()
my_solver.SetMaxIterations(600)
my_system.SetSolver(my_solver)

my_system.Set_G_acc(chrono.ChVectorD(0,-9.8,0))

# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#  SOME MODIFICATIONS....

# ***TRICK***
# Fetch a ChMarker from its name (it is a 'Coordinate system' in
#  the SolidWorks interface)

my_marker = my_system.SearchMarker('Marker_shaft')
if not my_marker :
    sys.exit('Error: cannot find marker from its name in the C::E system!')

# ***TRICK***
# Fetch two ChBodyAuxRef objects (the ground, the shaft) from
# their names. Names are as they are named in SolidWorks - see also the dump of
# my_system object with my_system.ShowHierarchy(chrono.GetLog()) if needed)
#   Note.. here we must upcast because Search() returns generic shared
# pointer to a base class ChPhysicsItem, so we use CastToXXYYZZ()
# my_shaft = chrono.CastToChBodyAuxRefShared(my_system.Search('Crankshaft-1'))
# Or use the specialized SearchBody().

my_shaft = my_system.SearchBody('Crankshaft-1')
if not my_shaft :
    sys.exit('Error: cannot find shaft  from its name in the C::E system!')

my_ground = my_system.SearchBody('ground')
if not my_ground :
    sys.exit('Error: cannot find ground from its name in the C::E system!')

# ***TRICK***
# Create an engine along the Z direction of the coordsystem specified by
# the marker, and acting between shaft and ground

revolute_frame = my_marker.GetAbsFrame()
link_motor = chrono.ChLinkMotorRotationSpeed()
link_motor.Initialize(my_shaft, my_ground, revolute_frame)
link_motor.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)# Set_shaft_mode(chrono.ChLinkEngine.ENG_SHAFT_PRISM)
link_motor.SetMotorFunction(chrono.ChFunction_Const(1.0*chrono.CH_C_2PI))  # 1.0 Hz to rad/s
my_system.Add(link_motor)




if m_visualization == "pov":

    # ---------------------------------------------------------------------
    #
    #  Render a short animation by generating scripts
    #  to be used with POV-Ray
    #

    pov_exporter = postprocess.ChPovRay(my_system)

    # Set the path where it will save all .pov, .ini, .asset and .dat files,
    # this directory will be created if not existing. For example:
    pov_exporter.SetBasePath("povray_pychrono_generated")
    pov_exporter.SetTemplateFile("_template_POV.pov")

     # Sets the viewpoint, aimed point, lens angle
    pov_exporter.SetCamera(chrono.ChVectorD(0.4,0.6,0.9), chrono.ChVectorD(0.2,0,0), 30)

     # Sets the default ambient light and default light lamp
    pov_exporter.SetAmbientLight(chrono.ChColor(1,1,1))
    pov_exporter.SetLight(chrono.ChVectorD(-2,2,-1), chrono.ChColor(1.1,1.2,1.2), True)

     # Sets other settings
    pov_exporter.SetPictureSize(640,480)
    pov_exporter.SetAmbientLight(chrono.ChColor(2,2,2))

     # Turn on the rendering of xyz axes for the centers of gravity or reference frames:
    #pov_exporter.SetShowCOGs  (1, 0.05)
    #pov_exporter.SetShowFrames(1, 0.02)
    #pov_exporter.SetShowLinks(1, 0.03)
    if (False) :
        pov_exporter.SetShowContacts(1,
                                postprocess.ChPovRay.ContactSymbol_VECTOR_SCALELENGTH,
                                0.2,    # scale
                                0.0007, # width
                                0.1,    # max size
                                1,0,0.5 ) # colormap on, blue at 0, red at 0.5

    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    #  SOME MODIFICATION....

    # ***TRICK***
    # Add a POVray steel material to the shaft for enhanced photorealism
    # Thank to the 'assets' system, it is possible to add custom POV statements
    # to the the visualization shapes.

    if (True):
        pov_exporter.SetCustomCommands(my_shaft,'''
           pigment { color rgbt <0.5,0.5,0.52,0> }
           finish  {    reflection {0.35}
                        ambient 0
                        diffuse 1
                        phong 0.9
                        phong_size 60
                        metallic } ''')
        
    # ***TRICK***
    # Add an horizontal grid and a gray plane; also add a light source.
    # Use the SetCustomPOVcommandsScript() statement to add POV commands
    # to the POV script generated by Chrono::Engine.

    pov_exporter.SetCustomPOVcommandsScript(
    '''
    light_source{ <1,3,1.5> color rgb<1.1,1.1,1.1> }
    object{ Grid(0.1,0.04, rgb<0.5,0.5,0.5>, rgbt<1,1,1,1>) translate -0.3*y }
    plane{<0,1,0>, 0 pigment{color rgb<0.8,0.8,0.8>} translate -0.301*y }
    ''')

    # ***TRICK***
    # Add a camera that moves together with one of the connecting rods;
    # note that position and aimpoint are set in conrod coordinate
    # system.

    if (False):
        my_rod = my_system.SearchBody('piston_rod-2/ConRod-1')
        if my_rod.IsNull() :
            sys.exit('Error: cannot find conrod from its name in the C::E system!')

        my_movingcamera = chrono.ChCamera()
        my_movingcamera.SetPosition(chrono.ChVectorD(0,-0.1,-0.700))
        my_movingcamera.SetAimPoint(chrono.ChVectorD(0,-0.1,0))
        #my_movingcamera.SetOrthographic(True)
        my_rod.GetAssets().push_back(my_movingcamera)


    # ***TRICK***
    # Show reference frames of constraints as small RGB small coordinate systems.
    # Also make all bodies semi transparent in POVray raytracing, so that
    # you can see better where the constraint coordinate sytstems are.

    if (False):
        pov_exporter.SetShowLinks(1, 0.03)
        #pov_exporter.SetShowCOGs  (1, 0.05)
        #pov_exporter.SetShowFrames  (1, 0.05)

        for aitem in chrono.IterOtherPhysicsItems(my_system):
            pov_exporter.SetCustomCommands(aitem,'''
              pigment { color rgbt <1,1,1,0.8> }
            ''')
                                          


    #  END OF MODIFICATIONS....
    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



     # Tell which physical items you want to render
    pov_exporter.AddAll()


     # Create the two .pov and .ini files for POV-Ray (this must be done
     # only once at the beginning of the simulation).
    pov_exporter.ExportScript()


     # Perform a short simulation
    nstep =0
    while (my_system.GetChTime() < m_length) :

        my_system.DoStepDynamics(m_timestep)

        #if math.fmod(nstep,10) ==0 :
        print ('time=', my_system.GetChTime() )

            # Create the incremental nnnn.dat and nnnn.pov files that will be load
            # by the pov .ini script in POV-Ray (do this at each simulation timestep)
        pov_exporter.ExportData()

        nstep = nstep +1

    print ("\n\nOk, Simulation done!");
    print ("\n\nGenerated .pov and .ini files for POVray.");
    time.sleep(2)


if m_visualization == "irrlicht":

	# ---------------------------------------------------------------------
	#
	#  Create an Irrlicht application to visualize the system
	#

    # Create the Irrlicht visualization
    vis = chronoirr.ChVisualSystemIrrlicht()
    vis.AttachSystem(my_system)
    vis.SetWindowSize(1024,768)
    vis.SetWindowTitle('Test')
    vis.Initialize()
    vis.AddLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
    vis.AddSkyBox()
    vis.AddCamera(chrono.ChVectorD(0.5, 0.5, 0.5))
    vis.AddTypicalLights()
    
    # ==IMPORTANT!== Use this function for adding a ChIrrNodeAsset to all items
    				# in the system. These ChIrrNodeAsset assets are 'proxies' to the Irrlicht meshes.
    				# If you need a finer control on which item really needs a visualization proxy in
    				# Irrlicht, just use application.AssetBind(myitem); on a per-item basis.
    #vis.BindAll()
       
    m_realtime_timer = chrono.ChRealtimeStepTimer()

    
    # Simulation loop
    while vis.Run():
        vis.BeginScene()
        vis.Render()
        vis.EndScene()
        my_system.DoStepDynamics(m_timestep)
        m_realtime_timer.Spin(m_timestep)


