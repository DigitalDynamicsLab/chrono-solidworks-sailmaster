#-------------------------------------------------------------------------------
#
# This file shows how to simulate collision shapes
#
# Author: Alessandro Tasora
#
# REMARK: this is part of Chrono::Solidworks add-in
#     - it assumes that you exported the .asm in this directory using the add-in
#     - PyChrono must be installed in your Python environment
#-------------------------------------------------------------------------------

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as chronoirr

# ***TRICK***
# Set the default outward/inward shape margins for collision detection,
# this is epecially important for very large or very small objects.
# This is a global setting to be put BEFORE creating objects/systems
chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.005)
chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.005)


# ---------------------------------------------------------------------
#
# Parse command-line parameters

m_timestep = 0.001
m_length = 4.0
m_visualization = "irrlicht" # use "irrlicht" (realtime 3D) or "pov" (raytracing postprocess)
m_datapath = "C:/Program Files/chrono_solidworks/data/" 

# For irrlicht fonts & background. Adjust to your path
chrono.SetChronoDataPath(m_datapath)

# ---------------------------------------------------------------------
#
#  load the file generated by the SolidWorks CAD plugin
#  and add it to the ChSystem.
#
#  This is usually done as
#    from my_module import exported_items
#  but here is 'my_module' is a string, so there's a workaround with 'exec'


print ("Loading C::E scene...");

exported_items = chrono.ImportSolidWorksSystem('./collisions')

print ("...loading done!");


# Print exported items
for my_item in exported_items:
    print (my_item.GetName())

# Add items to the physical system
my_system = chrono.ChSystemNSC()
for my_item in exported_items:
    my_system.Add(my_item)



# ***TRICK***
# Create a contact material (surface property)to share between all objects.

brick_material = chrono.ChMaterialSurfaceNSC()
brick_material.SetFriction(0.6)
#brick_material.SetRestitution(0)
#brick_material.SetDampingF(0.05)
#brick_material.SetCompliance (0.000000003)
#brick_material.SetComplianceT(0.000000001)


for my_body in my_system.Get_bodylist(): 
    my_body.SetMaterialSurface(brick_material)


# Rendering for the POV raytracing:

marble_povmat = postprocess.ChPovRayAssetCustom()
marble_povmat.SetCommands('''
       texture{T_Stone8}
        ''')

for my_body in my_system.Get_bodylist(): 
        my_body.AddAsset(marble_povmat)


floor_povmat = postprocess.ChPovRayAssetCustom()
floor_povmat.SetCommands('''
       texture{T_Stone9}
        ''')


# ***TRICK***
# Create motion between table and ground:

my_floor = my_system.SearchBody('floor^portal-1')
if not my_floor :
    sys.exit('Error: cannot find floor  from its name in the C::E system!')
my_floor.AddAsset(floor_povmat)

my_ground = my_system.SearchBody('ground')
if not my_ground :
    sys.exit('Error: cannot find ground  from its name in the C::E system!')

# make the shaking motion
my_floor.SetBodyFixed(False)
link_shaker = chrono.ChLinkLockLock()
link_shaker.Initialize(my_floor, my_ground, chrono.CSYSNORM)
my_system.Add(link_shaker)


my_functA = chrono.ChFunction_Sine(0,1.4,0.06)
my_functA.thisown = 0
my_functB = chrono.ChFunction_Sine(0,0.1,1)
my_functB.thisown = 0
my_funct = chrono.ChFunction_Operation()
my_funct.Set_fa(my_functA)
my_funct.Set_fb(my_functB)
my_funct.Set_optype(chrono.ChOP_MUL)
my_funct.thisown = 0
link_shaker.SetMotion_X(my_funct)


if m_visualization == "pov":
    # ---------------------------------------------------------------------
    #
    #  Render a short animation by generating scripts
    #  to be used with POV-Ray
    #

    pov_exporter = postprocess.ChPovRay(my_system)

     # Sets some file names for in-out processes.
    pov_exporter.SetTemplateFile        ("_template_POV.pov")
    pov_exporter.SetOutputScriptFile    ("rendering_frames.pov")
    if not os.path.exists("output"):
        os.mkdir("output")
    if not os.path.exists("anim"):
        os.mkdir("anim")
    pov_exporter.SetOutputDataFilebase("output/my_state")
    pov_exporter.SetPictureFilebase("anim/picture")

     # Sets the viewpoint, aimed point, lens angle
    pov_exporter.SetCamera(chrono.ChVectorD(3.2,1.3,3.5), chrono.ChVectorD(0.6,0.5,0), 32)

     # Sets the default ambient light and default light lamp
    pov_exporter.SetAmbientLight(chrono.ChColor(1,1,1))
    pov_exporter.SetLight(chrono.ChVectorD(-2,2,-1), chrono.ChColor(1.1,1.2,1.2), True)

     # Sets other settings
    pov_exporter.SetPictureSize(640,480)
    pov_exporter.SetAmbientLight(chrono.ChColor(2,2,2))

     # Turn on the rendering of xyz axes for the centers of gravity or reference frames:
    #pov_exporter.SetShowCOGs  (1, 0.05)
    #pov_exporter.SetShowFrames(1, 0.02)
    #pov_exporter.SetShowLinks(1, 0.03)
    if (False):
        pov_exporter.SetShowContacts(1,
                                postprocess.ChPovRay.SYMBOL_VECTOR_SCALELENGTH,
                                0.2,    # scale
                                0.0007, # width
                                0.1,    # max size
                                1,0,0.5 ) # colormap on, blue at 0, red at 0.5

     # Add additional POV objects/lights/materials in the following way, entering
     # an optional text using the POV scene description laguage. This will be
     # appended to the generated .pov file.
     # For multi-line strings, use the python ''' easy string delimiter.
    pov_exporter.SetCustomPOVcommandsScript(
    '''
    #include "stones.inc"
    light_source{ <1,3,1.5> color rgb<1,1,1> }
    ''')

     # Tell which physical items you want to render
    pov_exporter.AddAll()


     # Create the two .pov and .ini files for POV-Ray (this must be done
     # only once at the beginning of the simulation).
    pov_exporter.ExportScript()


     # Optionally set some solver parameters.
    #my_system.SetSolverType(chrono.ChSolver.Type_BARZILAIBORWEIN) # precise, more slow
    my_system.SetSolverType(chrono.ChSolver.Type_SOR)
    my_system.SetMaxItersSolverSpeed(70)
    my_system.Set_G_acc(chrono.ChVectorD(0,-9.8,0))

     # Perform a short simulation
    nstep =0
    while (my_system.GetChTime() < m_length) :

        my_system.DoStepDynamics(m_timestep)

        if math.fmod(nstep,10) ==0 :
            print ('time=', my_system.GetChTime() )

            # Create the incremental nnnn.dat and nnnn.pov files that will be load
            # by the pov .ini script in POV-Ray (do this at each simulation timestep)
            pov_exporter.ExportData()

        nstep = nstep +1

    print ("\n\nOk, Simulation done!");
    time.sleep(2)


if m_visualization == "irrlicht":

	# ---------------------------------------------------------------------
	#
	#  Create an Irrlicht application to visualize the system
	#

	myapplication = chronoirr.ChIrrApp(my_system, 'Test', chronoirr.dimension2du(1280,720))

	myapplication.AddTypicalSky(chrono.GetChronoDataPath() + 'skybox/')
	myapplication.AddTypicalLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
	myapplication.AddTypicalCamera(chronoirr.vector3df(1,1,1),chronoirr.vector3df(0.0,0.0,0.0))
	myapplication.AddTypicalLights()
	#myapplication.AddLightWithShadow(chronoirr.vector3df(10,20,10),chronoirr.vector3df(0,2.6,0), 10 ,10,40, 60, 512);

				# ==IMPORTANT!== Use this function for adding a ChIrrNodeAsset to all items
				# in the system. These ChIrrNodeAsset assets are 'proxies' to the Irrlicht meshes.
				# If you need a finer control on which item really needs a visualization proxy in
				# Irrlicht, just use application.AssetBind(myitem); on a per-item basis.

	myapplication.AssetBindAll();

				# ==IMPORTANT!== Use this function for 'converting' into Irrlicht meshes the assets
				# that you added to the bodies into 3D shapes, they can be visualized by Irrlicht!

	myapplication.AssetUpdateAll();

				# ==IMPORTANT!== Use this function for enabling cast soft shadows

	#myapplication.AddShadowAll();

	# ---------------------------------------------------------------------
	#
	#  Run the simulation forever until windows is closed
	#

	myapplication.SetTimestep(m_timestep);
	
	while(myapplication.GetDevice().run()):
		myapplication.BeginScene()
		myapplication.DrawAll()
		myapplication.DoStep()
		myapplication.EndScene()

